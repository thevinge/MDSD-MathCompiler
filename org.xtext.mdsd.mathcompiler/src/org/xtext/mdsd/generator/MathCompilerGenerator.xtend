/*
 * generated by Xtext 2.20.0
 */
package org.xtext.mdsd.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.mdsd.mathCompiler.MathExp
import org.xtext.mdsd.mathCompiler.Plus
import org.xtext.mdsd.mathCompiler.Minus
import org.xtext.mdsd.mathCompiler.Mult
import org.xtext.mdsd.mathCompiler.Divi
import org.xtext.mdsd.mathCompiler.Binary
import org.xtext.mdsd.mathCompiler.VarReference
import org.xtext.mdsd.mathCompiler.Variable
import org.xtext.mdsd.mathCompiler.FunctionalBind
import org.xtext.mdsd.mathCompiler.Parenthesis
import org.xtext.mdsd.mathCompiler.Constant
import org.xtext.mdsd.mathCompiler.MathProgram
import org.xtext.mdsd.mathCompiler.ExternalDef
import org.xtext.mdsd.mathCompiler.Ext

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathCompilerGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {

		val Program = resource.allContents.filter(MathProgram).next
		
		fsa.generateFile("MathProgram.java",Program.generateMathProgram)
	}
	
	def CharSequence generateMathProgram(MathProgram program){
		'''
		// Generated file
		import java.util.*;
		
		public class MathProgram {
			
			«IF program.declarations.filter(ExternalDef).size > 0»
			public static class Externals {
				«FOR ExtDef : program.declarations.filter(ExternalDef)»
				public int «ExtDef.name»(«FOR parameter : ExtDef.parameters SEPARATOR ','»int «parameter.varName»«ENDFOR»);
				«ENDFOR»
			}
			
			privat Externals externals;
			
			public MathProgram(Externals _externals){
				externals = _externals;	
			}
			«ENDIF»
			«IF program.declarations.filter(ExternalDef).size == 0»
			public MathProgram(){}
			«ENDIF»
			
			public void compute(){
				«FOR Exp : program.declarations.filter(MathExp)»
				System.out.println("«Exp.name» = " + «Exp.compileExp»);
				«ENDFOR»
			}
		}	
		'''
	}

	def CharSequence compileExp(MathExp math) {'''(«math.exp.compileExp»)'''}

	def dispatch CharSequence compileExp(Binary binary) {
		'''«binary.left.compileExp» «binary.operator.compileOp» «binary.right.compileExp»'''
	}

	def dispatch CharSequence compileExp(Constant num) { '''«num.value»''' }

	def dispatch CharSequence compileExp(Parenthesis parenthesis) { '''(«parenthesis.expression.compileExp»)''' }

	def dispatch CharSequence compileExp(FunctionalBind functional) {
		'''«functional.body.compileExp»'''
	}

	def dispatch CharSequence compileExp(VarReference reference) { '''«reference.variable.compileExp»''' }

	def dispatch CharSequence compileExp(Variable variable) { '''«variable.expression.compileExp»''' }

	def dispatch CharSequence compileOp(Plus op) { '''+''' }

	def dispatch CharSequence compileOp(Minus op) { '''-''' }

	def dispatch CharSequence compileOp(Mult op) { '''*''' }

	def dispatch CharSequence compileOp(Divi op) { '''/''' }
	def dispatch CharSequence compileExp(Ext ext){
		'''externals.«ext.external.name»(«FOR arg: ext.arguments SEPARATOR ','»«arg»«ENDFOR»'''
	}
}
